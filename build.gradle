import net.fabricmc.mappingio.*
import net.fabricmc.mappingio.format.*
import net.fabricmc.mappingio.tree.*

buildscript {
    repositories {
        maven {
            name "Fabric Repository"
            url 'https://maven.fabricmc.net'
        }
    }

    dependencies {
        classpath 'net.fabricmc:mapping-io:0.3.0'
    }
}

plugins {
    id 'maven-publish'
}

static List<String> getPublishedVersions() {
    String xml

    try {
        xml = new URL("https://maven.glass-launcher.net/babric/babric/intermediary/maven-metadata.xml").text
    } catch (FileNotFoundException ignored) {
        return []
    }

    def metadata = new XmlSlurper().parseText(xml)
    def versions = metadata.versioning.versions.version*.text();
    return versions
}

def publishedVersions = getPublishedVersions()

def ENV = System.getenv()

def published = false
def localMappingsPath = "$buildDir/v2Mappings"
new File(localMappingsPath).mkdirs()
file('mappings').eachFile {
    if (!it.name.endsWith(".tiny")) return

    def mcVer = it.name.replace(".tiny", "")

    if (publishedVersions.contains(mcVer) && !(ENV.FORCE_PUBLISH == mcVer)) {
        project.logger.lifecycle("Skipping ${mcVer} as it has already been released")
        return
    } else {
        project.logger.lifecycle("Building ${mcVer}")
    }

    published = true

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")

    def conversionTask = "convert${it.name}ToV2"
    tasks.register(conversionTask) {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            MappingReader.read(v1MappingFile.toPath(), memoryMappingTree)
            try (MappingWriter mappingWriter = MappingWriter.create(v2MappingFile.toPath(), MappingFormat.TINY_2)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    Jar makeV1Jar = makeJar(mcVer, v1MappingFile, false)
    Jar makeV2Jar = makeJar(mcVer, v2MappingFile, true)

    makeV2Jar.dependsOn conversionTask

    publishing {
        publications {
            create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
                groupId "babric"
                artifactId "intermediary"
                version mcVer
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
        }
    }
}

if (!published) {
    throw new RuntimeException("Nothing to publish, override with the FORCE_PUBLISH env")
}

def makeJar(String mcVersion, File mappings, boolean v2) {
    def jarFilename = "intermediary-" + mcVersion + (v2 ? "-v2" : "")
    return task("${mcVersion}_makeJar" + (v2 ? "v2" : ""), type: Jar) {
        baseName jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        destinationDirectory = file("build/jars")
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
            }
        }
    }
}