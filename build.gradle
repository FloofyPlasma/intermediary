import net.fabricmc.mappingio.*
import net.fabricmc.mappingio.adapter.*
import net.fabricmc.mappingio.format.*
import net.fabricmc.mappingio.tree.*

buildscript {
    repositories {
        maven {
            name "Fabric Repository"
            url 'https://maven.fabricmc.net'
        }
    }

    dependencies {
        classpath 'net.fabricmc:mapping-io:0.6.1'
    }
}

plugins {
    id 'maven-publish'
}

static List<String> getPublishedVersions() {
    String xml

    try {
        xml = new URL("https://maven.glass-launcher.net/babric/babric/intermediary/maven-metadata.xml").text
    } catch (FileNotFoundException ignored) {
        return []
    }

    def metadata = new XmlSlurper().parseText(xml)
    def versions = metadata.versioning.versions.version*.text();
    return versions
}

tasks.register("build")

def publishedVersions = getPublishedVersions()

def ENV = System.getenv()

def published = false
def localMappingsPath = "$buildDir/v2Mappings"
def localv1NewMappingsPath = "$buildDir/v1NewMappings"
def localv2NewMappingsPath = "$buildDir/v2NewMappings"
new File(localMappingsPath).mkdirs()
new File(localv1NewMappingsPath).mkdirs()
new File(localv2NewMappingsPath).mkdirs()
file('mappings').eachFile {
	if (!it.name.endsWith(".tiny")) return

	def mcVer = it.name.replace(".tiny", "")

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")
    File v1NewMappingFile = new File("$localv1NewMappingsPath/${it.name}")
    File v2NewMappingFile = new File("$localv2NewMappingsPath/${it.name}")

	def conversionTask = tasks.register("convert${it.name}ToV2") {
		group = "V2 Conversion"
		inputs.file(v1MappingFile)
		outputs.file(v2MappingFile)

		doLast {
            def memoryMappingTree = new MemoryMappingTree()
            MappingNsCompleter nsCompleter = new MappingNsCompleter(memoryMappingTree, Map.of("glue", "intermediary", "server", "intermediary", "client", "intermediary"));
            MappingReader.read(v1MappingFile.toPath(), nsCompleter)
            try (MappingWriter mappingWriter = MappingWriter.create(v2MappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def newV1Task = "toNewV1"
    tasks.register(newV1Task) {
        group = "New V1 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v1NewMappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            MappingDstNsReorder reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            MappingNsRenamer renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v1MappingFile.toPath(), renamer)
            try (MappingWriter mappingWriter = MappingWriter.create(v1NewMappingFile.toPath(), MappingFormat.TINY_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def newV2Task = "toNewV2"
    tasks.register(newV2Task) {
        group = "New V2 Conversion"
        inputs.file(v2MappingFile)
        outputs.file(v2NewMappingFile)
        dependsOn(conversionTask)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            MappingDstNsReorder reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            MappingNsRenamer renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v2MappingFile.toPath(), renamer)
            try (MappingWriter mappingWriter = MappingWriter.create(v2NewMappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
		}
	}

    Jar makeV1Jar = makeJar(mcVer, v1MappingFile, false, false)
    Jar makeV2Jar = makeJar(mcVer, v2MappingFile, true, false)
    Jar makeFixedV1Jar = makeJar(mcVer, v1NewMappingFile, false, true)
    Jar makeFixedV2Jar = makeJar(mcVer, v2NewMappingFile, true, true)

    makeV2Jar.dependsOn conversionTask
    makeFixedV1Jar.dependsOn newV1Task
    makeFixedV2Jar.dependsOn newV2Task

    publishing {
        publications {
            create("${mcVer.replace(" ", "")}_mavenJava", MavenPublication) {
                groupId "babric"
                artifactId "intermediary"
                version mcVer
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
            create("${mcVer.replace(" ", "")}Fixed_mavenJava", MavenPublication) {
                groupId "babric"
                artifactId "intermediary-fixed"
                version mcVer
                artifact(makeFixedV1Jar.archiveFile) {
                    builtBy makeFixedV1Jar
                }
                artifact(makeFixedV2Jar.archiveFile) {
                    builtBy makeFixedV2Jar
                    classifier = "v2"
                }
            }
        }
    }
}

if (!published) {
    throw new RuntimeException("Nothing to publish, override with the FORCE_PUBLISH env")
}

def makeJar(String mcVersion, File mappings, boolean v2, boolean fixed) {
    def jarFilename = "intermediary-" + (fixed ? "fixed-" : "") + mcVersion + (v2 ? "-v2" : "")
    return task("${mcVersion}_makeJar" + (v2 ? "v2" : "") + (fixed ? "Fixed" : ""), type: Jar) {
        baseName jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        destinationDirectory = file("build/jars")
    }
}
publishing {
    repositories {
        mavenLocal()
        maven {
            name = "localDistribution"
            url = uri("$buildDir/dist")
        }
    }
}
